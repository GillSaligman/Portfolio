<!-- HTML STRUCTURE FOR ROBOTIC ARM PROJECT PAGE -->

<!-- Section: Overview -->
<section class="wrapper style1">
  <div class="inner">
    <h2 class="major">Overview</h2>
    <p><strong>Inspired by NASA's RASC-AL competition, my senior design team created a lunar maintenance rover with a modular advanced manipulator, a custom chassis, and distributed control built for adaptability, repairability, and upgradeability.</strong></p>
    <details>
      <summary>More Details</summary>
      <p>This system was not intended to be hermetically sealed or moon-ready, but instead served as a platform to test modularity, distributed control, and systems integration in a university setting. The project emphasized hands-on engineering over theoretical design, allowing for iteration and real-world learning across disciplines.</p>
    </details>
  </div>
</section>

<!-- Section: Project Highlights -->
<section class="wrapper alt style2">
  <div class="inner">
    <h2 class="major">Project Highlights</h2>
    <p><strong>I was Team Leader on a 4-person Drexel senior design team. I built the entire robotic system — mechanical, electrical, embedded, and control — while others contributed to documentation and presentations. I oversaw everything from design to final testing.</strong></p>
    <details>
      <summary>More Details</summary>
      <p>Using NASA's challenge statement as a springboard, we explored different approaches to long-term lunar maintenance. We ultimately pursued a modular robotic arm design because of its serviceability, upgradeability, and long-term reliability in remote conditions. We then designed and built a custom rover chassis to carry the arm and implemented a distributed control system using ROS 2-inspired architecture.</p>
    </details>
  </div>
</section>

<!-- Section: Mechanical Design -->
<section class="wrapper style1">
  <div class="inner">
    <h2 class="major">Mechanical Design</h2>
    <p><strong>We started with simulations to choose a joint layout that minimized singularities. Then I calculated torque requirements based on payload goals and iteratively designed each joint from J3 to J7 around a 1x1 aluminum skeleton.</strong></p>
    <details>
      <summary>More Details</summary>
      <p>The joints were 3D-printed with PLA, PETG, and ABS depending on the load requirements. All brackets, mounts, and gears were custom-designed. We originally planned to include a harmonic drive but didn’t incorporate it due to time constraints. J6 posed a unique challenge: it rotates axially and required full constraint in all directions. I used axial thrust bearings and radial bearings for stabilization while preserving a hollow center for gripper wiring. We geared down the potentiometer on J6 to extend its range of motion from 270° to nearly 600° at the cost of resolution.</p>
      <p>We built from the end effector backward, testing each joint as it was completed. To avoid dependency issues, joints were independently controlled. We also assumed estimated motor masses to avoid analysis paralysis and verified that actual selections met or beat our assumptions.</p>
    </details>
  </div>
</section>

<!-- Section: Electronics -->
<section class="wrapper alt style2">
  <div class="inner">
    <h2 class="major">Electronics</h2>
    <p><strong>Each joint has its own ESP8266 microcontroller, potentiometer, and motor driver — connected to a shared 4-wire power bus for simple modularity and easy replacements.</strong></p>
    <details>
      <summary>More Details</summary>
      <p>We tested many microcontrollers before choosing ESP8266 modules for their low cost, Wi-Fi support, and analog input. CircuitPython was too slow for real-time control, so we used MicroPython. Each joint board is fully independent, allowing joints to be added or removed without system changes. The joints tap into the 12V/24V and 5V lines snaked up through the arm.</p>
      <p>The chassis contains off-the-shelf hobbyist electronics: 12V and 24V power supplies, buck converters, fuses, and a Raspberry Pi 4 that manages all system communication. This electronics architecture enabled us to scale quickly while staying under budget.</p>
    </details>
  </div>
</section>

<!-- Section: Software & Control -->
<section class="wrapper style1">
  <div class="inner">
    <h2 class="major">Software & Control</h2>
    <p><strong>The control system is distributed: A Raspberry Pi hosts a Wi-Fi network and MQTT broker, connecting to ESPs in each joint and bridging commands from a controller or terminal via ROS 2-inspired architecture.</strong></p>
    <details>
      <summary>More Details</summary>
      <p><strong>Connection Protocol:</strong> A laptop connects to the RPi’s Wi-Fi (set up using hostapd and dnsmasq). The RPi runs Mosquitto for MQTT messaging. From the laptop, we SSH in and start Python scripts to control the system.</p>
      <p><strong>Data Structure:</strong> Three types of 7-slot brackets were used: Controller, Desired, and Actual — each formatted as [DL, DR, J3, J4, J5, J6, J7]. Controller data came from an Xbox controller. In Velocity Mode, the RPi sends values like V0.45 for joint velocity. In Position Mode, the user inputs joint positions manually, sending values like P45.00 for target angles. ESPs always send actual angles based on potentiometer readings.</p>
      <p><strong>ESP Logic:</strong> Each ESP connects to Wi-Fi, listens for its joint's command in the Desired bracket, and runs PID control to reach the target angle. If given a velocity value, the motor drives in that direction with soft stops. We created custom potentiometer-to-angle regressions for every joint.</p>
    </details>
  </div>
</section>

<!-- Section: Prototyping & Assembly -->
<section class="wrapper alt style2">
  <div class="inner">
    <h2 class="major">Prototyping & Assembly</h2>
    <p><strong>We built and tested each joint independently, ensuring software and electronics were robust even if only one joint was active. This modularity prevented integration issues.</strong></p>
    <details>
      <summary>More Details</summary>
      <p>The system worked from the end effector backwards. J6 and the gripper were developed first, with the software already functional — simply ignoring unused bracket slots. As new joints were added, the same software was reused, requiring only updates to the Desired bracket values. This flexible strategy allowed the full system to come online incrementally with minimal overhead.</p>
    </details>
  </div>
</section>

<!-- Section: Takeaways & Future Work -->
<section class="wrapper style1">
  <div class="inner">
    <h2 class="major">Takeaways & Future Work</h2>
    <p><strong>This platform will be passed on to future Drexel engineering students as a foundation for learning, testing, and expanding robotic systems.</strong></p>
    <details>
      <summary>More Details</summary>
      <p>Our professor plans to use it for PID tuning demos, and younger students want to work on improving the chassis, adding joints, swapping end effectors, and integrating new control modes. I created robust documentation to ensure this platform can grow well beyond our original scope.</p>
    </details>
  </div>
</section>
